<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Go sync包分析 :: jiayuan&#39;s Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="并发编程 读写锁 互斥锁" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="/posts/golang-sync-package/" />






  
  
  
  
  
  <link rel="stylesheet" href="/styles.css">







  <link rel="shortcut icon" href="/img/theme-colors/orange.png">
  <link rel="apple-touch-icon" href="/img/theme-colors/orange.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Go sync包分析">
<meta property="og:description" content="并发编程 读写锁 互斥锁" />
<meta property="og:url" content="/posts/golang-sync-package/" />
<meta property="og:site_name" content="jiayuan&#39;s Blog" />

  
    <meta property="og:image" content="/img/favicon/orange.png">
  

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2024-06-13 23:00:00 &#43;0800 &#43;0800" />












</head>
<body class="orange">


<div class="container full">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    jiayuan&#39;s Blog
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/tags">Tags</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about" >About</a></li>
        
      
        
          <li><a href="/tags" >Tags</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="/posts/golang-sync-package/">Go sync包分析</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-06-13</time></div>

  
    <span class="post-tags">
      
      #<a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>&nbsp;
      
      #<a href="/tags/%E8%AF%BB%E5%86%99%E9%94%81/">读写锁</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h1 id="syncrwmutex">sync.RWMutex<a href="#syncrwmutex" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>读者写者是经典的进程同步问题</p>
<p>按照实现的优先级可以分为读者优先、读写公平、写者优先</p>
<h3 id="读者优先">读者优先<a href="#读者优先" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>如下伪码实现</p>
<pre tabindex="0"><code>type RWMutex struct {
	rmutex sync.Mutex
	wmutex sync.Mutex
	readerCnt int
}

func RLock() {
	rmutex.Lock
	r := ++readerCnt

	if r == 1  {wmutex.Lock} // 应该在rmutex内调用

	rmutex.Unlock
}

func RUnlock() {
	rmutex.Lock
	r := --readerCnt

	if r == 0 {wmutex.Unlock} // 应该在rmutex内调用

	rmutex.Unlock
}

func Lock() {
	wmutex.Lock()
}

func Unlock() {
	wmutex.Unlock()
}
</code></pre><p>注意，RLock中 if r == 1   RUnlock中if r == 0 的逻辑要在持有rmutex时进行</p>
<ul>
<li>如果RLock中 if r==1在rmutex.Unlock之后&hellip;</li>
<li>如果RUnlock中if r==0在rmutex.Unlock之后&hellip;</li>
</ul>
<p>Rlock 先锁rmutex，读者数量自增， 如果是第一个读者，锁住wmutex</p>
<ul>
<li>如果在RLock前有写者持有写锁，第一个读者阻塞在wmutex.Lock，后续的RLock请求会阻塞在rmutex.Lock</li>
<li>如果第一个RLock时没有写者，第一个RLock加wmutex成功， 后续的写会等待，读者可以进入</li>
<li>持续有读请求，写者可能会饥饿</li>
</ul>
<h3 id="写者优先">写者优先<a href="#写者优先" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre tabindex="0"><code>type RWMutex struct {
	rcntmu sync.Mutex
	wcntmu sync.Mutex
	wmu sync.Mutex // 写者互斥
	mu sync.mutex  // 读者加锁时需要锁，第一个写进入时锁，写者最后一个退出时解锁
	readerCnt int
	writerCnt int
}

func RLock() {
	mu.Lock  // 第一步获取mu
	rcntmu.Lock
	r := ++readerCnt

	if r == 1  {wmutex.Lock} // 应该在rcntmu内调用

	rcntmu.Unlock

	mu.Unlock
}

func RUnlock() {
	rcntmu.Lock
	r := --readerCnt

	if r == 0 {wmutex.Unlock} // 应该在rcntmu内调用

	rcntmu.Unlock
}

func Lock() {
	wcntmu.Lock
	w := ++writerCnt
	if w == 1 { mu.Lock } // 第一个写者，Lock mu，阻塞后来的读
	wcntmu.Unlock

	wmu.Lock // 写互斥
}

func Unlock() {
	wcntmu.Lock
	w := --writerCnt
	if w == 0 { mu.UnLock }  // 最后一个写退出，解锁
	wcntmu.Unlock

	wmu.Unlock
}
</code></pre><p>读RLock时需要获取mu，</p>
<p>写Lock时，第一个写者竞争mu，持有后等待最后一个写者Unlock时Unlock mu</p>
<p>写者优先级高于读者</p>
<h2 id="读写公平">读写公平<a href="#读写公平" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>省略</p>
<h2 id="go实现">Go实现<a href="#go实现" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>利用原子变量</p>
<pre tabindex="0"><code>type RWMutex struct {
	w           Mutex        // held if there are pending writers
	writerSem   uint32       // semaphore for writers to wait for completing readers
	readerSem   uint32       // semaphore for readers to wait for completing writers
	readerCount atomic.Int32 // number of pending readers
	readerWait  atomic.Int32 // number of departing readers
}

const rwmutexMaxReaders = 1 &lt;&lt; 30

func (rw *RWMutex) RLock() {
	if rw.readerCount.Add(1) &lt; 0 {
		// A writer is pending, wait for it.
		runtime_SemacquireRWMutexR(&amp;rw.readerSem, false, 0)
	}
}

func (rw *RWMutex) RUnlock() {
	if r := rw.readerCount.Add(-1); r &lt; 0 {
		// Outlined slow-path to allow the fast-path to be inlined
		rw.rUnlockSlow(r)
	}
}

func (rw *RWMutex) rUnlockSlow(r int32) {
	// A writer is pending.
	if rw.readerWait.Add(-1) == 0 {
		// The last reader unblocks the writer.
		runtime_Semrelease(&amp;rw.writerSem, false, 1)
	}
}

func (rw *RWMutex) Lock() {
	// First, resolve competition with other writers.
	rw.w.Lock()
	// Announce to readers there is a pending writer.
	r := rw.readerCount.Add(-rwmutexMaxReaders) + rwmutexMaxReaders
	// Wait for active readers.
	if r != 0 &amp;&amp; rw.readerWait.Add(r) != 0 {
		runtime_SemacquireRWMutex(&amp;rw.writerSem, false, 0)
	}
}

func (rw *RWMutex) Unlock() {
	// Announce to readers there is no active writer.
	r := rw.readerCount.Add(rwmutexMaxReaders)

	// Unblock blocked readers, if any.
	for i := 0; i &lt; int(r); i++ {
		runtime_Semrelease(&amp;rw.readerSem, false, 0)
	}
	// Allow other writers to proceed.
	rw.w.Unlock()
}
</code></pre><p>RLock增加readerCount，&lt;0表示有写者申请写锁或持有写锁，等待readerSem</p>
<p>RUnlock减少readerCount，&lt;0表示有写者申请写锁或持有写锁，进入慢路径rUnlockSlow</p>
<p>rUnlockSlow内减少readerWait，新值=0时，唤醒writerSem</p>
<p>写者Lock时串行的，写者之间用rw.w互斥</p>
<p>获取rw.w的写者将readerCount减小rwmutexMaxReaders(10.7亿)，并取到减小前的readerCount</p>
<p>如果原来的readerCount&gt;0，表示有读者已获取读锁，将readerWait增加读者数量，Add后不为0睡眠等待writerSem</p>
<p>写者Lock与读者RUnlock有关联</p>
<ul>
<li>写者加锁请求将readerCount减少10.7亿后，新来的读者会等待readerSem</li>
<li>现有的读者会进入rUnlockSlow，减少readerWait，=0唤醒writerSem
<ul>
<li>一种情况是在写者readerWait之前，全部现有读者RUnlock完毕，写者Add后为0，不需要等待writerSem；同时读者rUnlockSlow也不需要唤醒writerSem</li>
</ul>
</li>
</ul>
<p>写者Unlock时（一定没有正在进行的读者），将readerCount增加10.7亿，得到等待的读者数量</p>
<p>依次唤醒阻塞在readerSem上的读者</p>
<p>Go的实现不是&quot;写者优先&quot;，一个写者持有锁，新的写者与其余读者同时等待时，新的写者并不是高优处理</p>
<h1 id="syncmutex">sync.Mutex<a href="#syncmutex" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>异步Log文章中有简单分析</p>
<h1 id="synconce">sync.Once<a href="#synconce" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>double check</p>
<h1 id="syncmap">sync.Map<a href="#syncmap" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<h1 id="atomicvalue">atomic.Value<a href="#atomicvalue" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>

      </div></div>

  
    
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        
        <span class="button next">
            <a href="/posts/innodb-lock/">
                <span class="button__text">InnoDB加锁分析</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2024 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
