<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>InnoDB加锁分析 :: jiayuan&#39;s Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="数据库加锁分析 隔离级别" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="/posts/innodb-lock/" />






  
  
  
  
  
  <link rel="stylesheet" href="/styles.css">







  <link rel="shortcut icon" href="/img/theme-colors/orange.png">
  <link rel="apple-touch-icon" href="/img/theme-colors/orange.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="InnoDB加锁分析">
<meta property="og:description" content="数据库加锁分析 隔离级别" />
<meta property="og:url" content="/posts/innodb-lock/" />
<meta property="og:site_name" content="jiayuan&#39;s Blog" />

  
    <meta property="og:image" content="/img/favicon/orange.png">
  

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2024-06-12 00:00:00 &#43;0800 &#43;0800" />












</head>
<body class="orange">


<div class="container full">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    jiayuan&#39;s Blog
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/tags">Tags</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about" >About</a></li>
        
      
        
          <li><a href="/tags" >Tags</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="/posts/innodb-lock/">InnoDB加锁分析</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-06-12</time></div>

  
    <span class="post-tags">
      
      #<a href="/tags/mysql/">MySQL</a>&nbsp;
      
      #<a href="/tags/%E9%94%81/">锁</a>&nbsp;
      
      #<a href="/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/">隔离级别</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h1 id="加锁规则">加锁规则<a href="#加锁规则" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<ul>
<li>MySQL实战45讲总结的规则(5.x版本，规则可能会变化)</li>
</ul>
<p>两个“原则”、两个“优化”和一个“bug”：</p>
<p>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</p>
<p>原则 2：查找过程中访问到的对象才会加锁。</p>
<p>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</p>
<p>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</p>
<p>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p>
<ul>
<li>其他参考</li>
</ul>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html">不同语句加锁</a></p>
<p>MySQL8 performance_schema.data_locks;</p>
<h1 id="innodb-等值查询加锁分析">InnoDB 等值查询加锁分析<a href="#innodb-等值查询加锁分析" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>仅分析等值查询，范围查询比较复杂</p>
<ul>
<li>索引：唯一索引/非唯一索引</li>
<li>隔离级别：RR/RC</li>
<li>是否有符合条件的行：是/否</li>
</ul>
<h2 id="唯一索引">唯一索引<a href="#唯一索引" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>表结构</p>
<pre tabindex="0"><code>create table t (
 id int not null,
 uid int not null,
 val int not null,
 primary key (id),
 unique key uk_uid (uid)
) engine = innodb;

insert into t values (5, 5, 5), (10, 10, 10), (15, 15, 15), (20, 20, 20);
</code></pre><h3 id="rr隔离级别">RR隔离级别<a href="#rr隔离级别" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="命中行">命中行<a href="#命中行" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p><code>begin; select * from t where uid = 5 for update;</code></p>
<p>仅对记录5加锁</p>
<h4 id="未命中行">未命中行<a href="#未命中行" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>session1 <code>begin; select * from t where uid = 13 for update;</code>
锁(10, 15) 的gap，没有行锁</p>
<h3 id="rc隔离级别">RC隔离级别<a href="#rc隔离级别" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="命中行-1">命中行<a href="#命中行-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p><code>begin; select * from t where uid = 5 for update;</code></p>
<p>仅对记录5加锁</p>
<h4 id="未命中行-1">未命中行<a href="#未命中行-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>session1 <code>begin; select * from t where uid = 13 for update;</code></p>
<p>session1 没有gap lock，没有行锁</p>
<p>session2 可以插入任意间隙，可以更新已有记录</p>
<h2 id="非唯一索引">非唯一索引<a href="#非唯一索引" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>表结构</p>
<pre tabindex="0"><code>create table t (
 id int not null,
 uid int not null,
 val int not null,
 primary key (id),
 key idx_uid (uid)
) engine = innodb;

insert into t values (5, 5, 5), (10, 10, 10), (15, 15, 15), (20, 20, 20), (24, 20, 20), (28, 20, 20), (40, 40, 40);
</code></pre><h3 id="rr隔离级别-1">RR隔离级别<a href="#rr隔离级别-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="命中行-2">命中行<a href="#命中行-2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>session 1 <code>begin; select * from t where uid = 20 for update;</code></p>
<p>锁(20, 40) 的gap</p>
<p>3个uid=20的行锁</p>
<h4 id="未命中行-2">未命中行<a href="#未命中行-2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>session 1 <code>begin; select * from t where uid = 18 for update;</code></p>
<p>锁(15, 20(id=20))的 gap，可以插入(21, 20, 20)，不能插入(19, 20, 20)，注意非唯一索引，同一个索引值之间的间隙与主键id相关</p>
<p>uid=20(id=20)不需要加行锁</p>
<h3 id="rc隔离级别-1">RC隔离级别<a href="#rc隔离级别-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="命中行-3">命中行<a href="#命中行-3" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>session 1 <code>begin; select * from t where uid = 20 for update;</code></p>
<p>只加uid=20行锁</p>
<h4 id="未命中行-3">未命中行<a href="#未命中行-3" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>session 1 <code>begin; select * from t where uid = 18 for update;</code></p>
<p>不加锁</p>
<h2 id="结论">结论<a href="#结论" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>RR级别需要加gap lock，gap lock加record lock称作next-key lock</p>
<p>RC不需要加gap lock</p>
<ul>
<li>
<p>RR隔离级别（等值查询）</p>
<ul>
<li>唯一索引
<ul>
<li>命中时，锁命中的一条记录</li>
<li>未命中，锁间隙，下一条记录无需加行锁</li>
</ul>
</li>
<li>非唯一索引
<ul>
<li>命中时，锁间隙，锁符合条件的记录行锁</li>
<li>未命中时，锁间隙，下一条无需加行锁</li>
</ul>
</li>
</ul>
</li>
<li>
<p>RC隔离级别（等值查询）</p>
<ul>
<li>唯一索引
<ul>
<li>命中时，锁命中的一条记录</li>
<li>未命中时，无需加锁</li>
</ul>
</li>
<li>非唯一索引
<ul>
<li>命中时，锁命中的记录</li>
<li>未命中时，无需加锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="如何验证锁相关问题">如何验证锁相关问题<a href="#如何验证锁相关问题" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>InnoDB update未命中索引时，RR级别是否锁全表？
<ul>
<li>实际上是扫描主键，逐行加锁</li>
<li>验证：session 1，先锁住最后一个主键，session 2 进行更新，再对最后一个主键加锁时，需要等待，session 1更新第一个主键，会报死锁错误
<ul>
<li>说明未命中索引的更新并不是先加表锁，而是先加了行锁</li>
</ul>
</li>
</ul>
</li>
<li>RC级别，会提前释放不满足条件的行，是在语句执行完释放，还是在判断不满足条件后理解释放？
<ul>
<li>验证：同样可以session1锁住最后一行，session 2进行更新，where条件有不符合条件的，当阻塞在最后一行时，session 3更新被session 2释放的行</li>
</ul>
</li>
</ul>
<h1 id="怎么用锁实现各隔离级别">怎么用锁实现各隔离级别<a href="#怎么用锁实现各隔离级别" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<ol>
<li>读未提交
<ol>
<li>读不加锁，写加写锁
<ol>
<li>读不加锁，但是也能保证数据的正确。例如varchar(20)，不加锁也不会读错</li>
</ol>
</li>
</ol>
</li>
<li>读已提交
<ol>
<li>读加读锁，读完释放，写加写锁</li>
</ol>
</li>
<li>可重复读
<ol>
<li>读加读锁，事务提交释放，写加写锁</li>
</ol>
</li>
<li>串行化
<ol>
<li>读写都加锁</li>
</ol>
</li>
</ol>
<p>举例，有并发事务t1, t2</p>
<ul>
<li>
<p>读未提交，读不加锁，t2更新了一行， 还未提交，t1就可以读到，t2回滚，t1脏读</p>
</li>
<li>
<p>读已提交，读加读锁，t2更新一行，未提交时，t2持有写锁，t1读不到，t2提交后，t1加上读锁，可以读到</p>
</li>
<li>
<p>可重复读，t1读锁提交时释放，期间t2无法修改t1读到的记录，自然实现可重复读，但是仍然会有幻读，t2可以插入新记录</p>
</li>
<li>
<p>串行化，都加锁，不会出现幻读</p>
</li>
</ul>
<h2 id="mvcc实现">MVCC实现<a href="#mvcc实现" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>只用锁也能实现各个隔离级别，但是并发较低</p>
<p>写加写锁，大部分无法进行读</p>
<p>MVCC支持写时读快照版本，增加并发</p>

      </div></div>

  
    
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="/posts/golang-sync-package/">
                <span class="button__icon">←</span>
                <span class="button__text">Go sync包分析</span>
            </a>
        </span>
        
        
        <span class="button next">
            <a href="/posts/online-data-migrate/">
                <span class="button__text">在线数据迁移</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2024 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
