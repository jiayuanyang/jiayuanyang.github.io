<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Go异步日志实现 :: jiayuan&#39;s Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="线上IO打满，写日志阻塞，上游超时结束。 实现异步日志，并分析mutex与chan使用问题" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="/posts/golang-async-log/" />






  
  
  
  
  
  <link rel="stylesheet" href="/styles.css">







  <link rel="shortcut icon" href="/img/theme-colors/orange.png">
  <link rel="apple-touch-icon" href="/img/theme-colors/orange.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Go异步日志实现">
<meta property="og:description" content="线上IO打满，写日志阻塞，上游超时结束。 实现异步日志，并分析mutex与chan使用问题" />
<meta property="og:url" content="/posts/golang-async-log/" />
<meta property="og:site_name" content="jiayuan&#39;s Blog" />

  
    <meta property="og:image" content="/img/favicon/orange.png">
  

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2024-05-18 12:47:51 &#43;0800 &#43;0800" />












</head>
<body class="orange">


<div class="container full">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    jiayuan&#39;s Blog
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/tags">Tags</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about" >About</a></li>
        
      
        
          <li><a href="/tags" >Tags</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="/posts/golang-async-log/">Go异步日志实现</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-05-18</time></div>

  
    <span class="post-tags">
      
      #<a href="/tags/go/">Go</a>&nbsp;
      
      #<a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>&nbsp;
      
      #<a href="/tags/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/">问题定位</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h1 id="一问题背景">一、问题背景<a href="#一问题背景" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>线上某接口偶现pvlost，问题实例物理机所在磁盘都有大量<strong>磁盘IO</strong>，ioutil持续100%</p>
<h1 id="二分析">二、分析<a href="#二分析" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<ul>
<li>
<p>为什么pvlost？</p>
<ul>
<li>header中透传deadline，判断time.Now() &gt; deadline后，直接丢弃请求</li>
<li>框架在收到请求时立即打印一条请求日志</li>
<li>日志库实现类似go标准库的log，使用sync.Mutex保护buf，打印日志被<strong>串行化</strong></li>
<li>磁盘IO打满时，log.Info(&ldquo;msg&rdquo;)在Write时可能会<strong>阻塞N秒</strong>，后续的请求也被阻塞，打印日志后进入 time.Now() &gt; deadline 的判断时，已经超过了deadline，丢弃请求。对外表现为pvlost</li>
</ul>
</li>
<li>
<p>Write写文件会阻塞？</p>
<ul>
<li>文件Write只需要写到内核的cache中，由操作系统负责flush，IO压力大时，cache不足，打印日志会阻塞</li>
<li>线上遇到的case，一般<strong>阻塞3秒以下</strong></li>
<li>本次问题是物理机上部署的其他实例大量占用IO</li>
</ul>
</li>
</ul>
<p>写日志阻塞有以下解决方式</p>
<ol>
<li>硬件层面
<ol>
<li>更换SSD：SSD有着更高的读写性能、更高的IOPS</li>
<li>独立部署：不与其他占用IO大的实例混部</li>
</ol>
</li>
<li>服务层面
<ol>
<li>打印log不立即Write，将日志写到ctx上下文中（例如ctx提供Info、Error日志方法），回包后再Write，此时阻塞不影响请求</li>
<li><strong>异步日志</strong>：日志写到进程缓冲区，异步Write</li>
</ol>
</li>
</ol>
<p>其实，Write行为可以看作是异步的，内核有page cache，并且会定期flush</p>
<p>但是内核cache不足时，也是会阻塞</p>
<p>因此，异步日志本质是在进程内增加cache，不依赖内核的cache</p>
<hr>
<p>PS：起初并未怀疑是磁盘IO的问题，物理机有多磁盘，监控上需要选中对应磁盘才能看到相应监控</p>
<p>定位问题时最直接的表现是日志中时间乱序，故障时间前后几秒，日志中的时间是乱的，时间变化不合规律</p>
<p>正常的日志是下面这样，时间递增</p>
<pre tabindex="0"><code>2024-01-01 12:34:05.000 msg...
2024-01-01 12:34:05.100 msg...
2024-01-01 12:34:05.200 msg...
</code></pre><p>故障时，时间从5s到6s到7s，又会回到5s</p>
<pre tabindex="0"><code>2024-01-01 12:34:05.000 msg...
2024-01-01 12:34:06.100 msg...
2024-01-01 12:34:07.200 msg...
2024-01-01 12:34:05.000 msg...
2024-01-01 12:34:06.100 msg...
2024-01-01 12:34:05.000 msg...
</code></pre><p>有怀疑是时钟波动的问题，但是时钟波动概率还是很小，多次出现故障，并且时钟短时间频繁波动，排除</p>
<h1 id="三实现异步日志">三、实现异步日志<a href="#三实现异步日志" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>几种解决方式中，异步日志可行性最高。</p>
<p>当前日志库实现整体逻辑类似标准库log，额外增加了<strong>日志滚动</strong>功能，增加Info、Error等日志等级</p>
<pre tabindex="0"><code>// 标准库log
// A Logger represents an active logging object that generates lines of
// output to an io.Writer. Each logging operation makes a single call to
// the Writer&#39;s Write method. A Logger can be used simultaneously from
// multiple goroutines; it guarantees to serialize access to the Writer.
type Logger struct {
	mu        sync.Mutex // ensures atomic writes; protects the following fields
	prefix    string     // prefix on each line to identify the logger (but see Lmsgprefix)
	flag      int        // properties
	out       io.Writer  // destination for output
	buf       []byte     // for accumulating text to write
}
</code></pre><p>二者实现上对比</p>
<ul>
<li>
<p>标准库log</p>
<ul>
<li>out为io.Writer</li>
</ul>
</li>
<li>
<p>我们的日志库</p>
<ul>
<li>out为*os.File，使用到Write写日志、Close方法关闭日志。打开新文件，滚动到新文件</li>
</ul>
</li>
</ul>
<p>既然只用到Write、Close，那么可以将out定义为io.WriteCloser</p>
<p>提供fileWrapper方法， 将*os.File转为io.WriteCloser</p>
<p>未开启异步log时，out = file，开启异步log时，将file包装为异步WriteCloser</p>
<h3 id="31-简单实现利用chan-byte">3.1 简单实现：利用chan []byte<a href="#31-简单实现利用chan-byte" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre tabindex="0"><code>
type AsyncWriteCloser struct {
	*os.File
	ch    chan []byte
	close chan error
}

func NewAsyncWriteCloser(f *os.File) *AsyncWriteCloser {
	res := &amp;AsyncWriteCloser{
		File:  f,
		ch:    make(chan []byte, 1024),
		close: make(chan error),
	}
	go res.consume()
	return res
}

func (wc *AsyncWriteCloser) consume() {
	for b := range wc.ch {
		wc.File.Write(b)
	}
	wc.close &lt;- wc.File.Close()
}

func (wc *AsyncWriteCloser) Write(b []byte) (int, error) {
	copy := append([]byte(nil), b...)
	wc.ch &lt;- copy
	return len(b), nil
}

func (wc *AsyncWriteCloser) Close(b []byte) error {
	close(wc.ch)
	return &lt;-wc.close
}
</code></pre><p>注意：Write参数b要进行<strong>深拷贝</strong>。函数返回后，调用函数可以修改b的内容</p>
<p>这个实现：</p>
<ul>
<li>Write次数不变，Write在chan未满时立即返回，阻塞只会在consume中</li>
<li>多了一次内存拷贝， Write方法中的拷贝</li>
<li>[]byte对象多</li>
</ul>
<h3 id="32-优化实现积攒数据每秒写一次">3.2 优化实现：积攒数据，每秒写一次<a href="#32-优化实现积攒数据每秒写一次" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>先写到cur []byte, 写满cap后再写入chan，减少Write次数，避免产生大量[]byte对象</p>
<h4 id="write逻辑">Write逻辑<a href="#write逻辑" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<pre tabindex="0"><code>type AsyncWriteCloser2 struct {
	*os.File
	frozen chan []byte

	mu  sync.Mutex
	cur []byte

	closed  bool

	wg sync.WaitGroup
}

func (wc *AsyncWriteCloser2) Write(b []byte) (int, error) {
	wc.mu.Lock()
	defer wc.mu.Unlock()

	if wc.closed {
		return 0, errors.New(&#34;write into closed file&#34;)
	}

	l := len(b)
	if l+len(wc.cur) &lt;= cap(wc.cur) {
		wc.cur = append(wc.cur, b...)
		return l, nil
	}

	if len(wc.cur) &gt; 0 {
		// 阻塞send
		wc.frozen &lt;- wc.cur
		wc.cur = nil // TODO 池化
	}

	wc.cur = append(wc.cur, b...)
	return l, nil
}
</code></pre><p>此外， 当日志量过少时，写满cap需要一定时间，日志更新慢，需要增加<strong>每秒写一次</strong>的逻辑</p>
<h4 id="消费逻辑">消费逻辑<a href="#消费逻辑" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<pre tabindex="0"><code>func (wc *AsyncWriteCloser2) consume() {
	defer wc.wg.Done()

	ticker := time.NewTicker(time.Second)
	defer ticker.Stop()

	var exit bool
	for !exit {
		select {
		case b, ok := &lt;-wc.frozen:
			if !ok { // closed
				exit = true
				break
			}
			wc.File.Write(b)

		case &lt;-ticker.C:
			if len(wc.frozen) &gt; 0 {
				continue
			}

			wc.mu.Lock()
			// 此时 frozen可能满了
			if len(wc.cur) &gt; 0 {
				select {
				case wc.frozen &lt;- wc.cur: // 要写到frozen 顺序消费
					wc.cur = nil
				default:
					// 已经满了 or closed
				}
			}
			wc.mu.Unlock()
		}
	}
}
</code></pre><h4 id="close等待数据写完">Close等待数据写完<a href="#close等待数据写完" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>Close时，需要将已有数据写完，因此，在Close方法等待consume完成后调用文件Close</p>
<pre tabindex="0"><code>func (wc *AsyncWriteCloser2) waitLocked() {
	// cur还有数据， 写到frozen
	if len(wc.cur) &gt; 0 {
		wc.frozen &lt;- wc.cur
		wc.cur = nil
	}

	close(wc.frozen)
	wc.wg.Wait()
}

func (wc *AsyncWriteCloser2) Close(b []byte) error {
	wc.mu.Lock()
	defer wc.mu.Unlock()

	if wc.closed {
		return errors.New(&#34;closed&#34;)
	}
	wc.closed = true

	wc.waitLocked()

	return wc.File.Close()
}
</code></pre><p>乍一看没有问题，但是，这样可能会<strong>死锁</strong></p>
<p>waitLocked时持有mutex，当前chan已满，此时写入cur阻塞，等待consume消费fronze</p>
<p>如果consume的select触发ticker分支，ticker会加锁，保护cur，不会消费frozen，也就是waitLocked中无法写入chan</p>
<p>二者互相等待，死锁</p>
<p>问题发生在哪？cur写入chan阻塞？写cur移到File.Close前也会死锁</p>
<p>问题在于sync.Mutex不可重入， Close等待consume退出，consume内会尝试获取Close持有的锁</p>
<p>解决方式</p>
<ol>
<li>consume内使用TryLock，go1.18及以上可使用</li>
<li>waitLocked写入chan前，先Unlock
<ol>
<li>这个场景可以解决问题，但是不建议</li>
</ol>
</li>
<li>consume中select有两个分支，拆成<strong>2个goroutine</strong>，一个负责消费frozen，一个负责ticker加锁将cur写入frozen，Close还是等待consume退出，consume不加锁，不会有问题</li>
</ol>
<p>拆成2个goroutine，这种方法通用性很强</p>
<h3 id="33-避免重启丢日志">3.3 避免重启丢日志<a href="#33-避免重启丢日志" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>异步io.WriteCloser只要满足在Close时写完数据即可。</p>
<p>这样，服务重启时，就不可避免丢数据</p>
<p>一种选择提供Flush方法，收到信号Flush，但Flush后还会有日志，不能完全避免日志不丢失</p>
<p>为避免日志丢失，可以提供一个Stop方法（并不只是实现io.WriteCloser了），停止异步写，转变为同步写文件</p>
<p><strong>05-21补充</strong></p>
<p>上面说的关闭异步log的方法，是需要log库与自定义的异步io.WriteCloser相配合，二者有耦合</p>
<p>思考了下，应该在log内实现Stop方法，加锁，调用异步io.WriteCloser的Flush方法，此时可以将log的out切换为原本的file。 解除了二者的耦合！</p>
<h3 id="34-还能做些什么">3.4 还能做些什么<a href="#34-还能做些什么" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>增加统计信息，例如Write最大耗时，chan最大长度等</p>
<h3 id="35-过程中的一些问题">3.5 过程中的一些问题<a href="#35-过程中的一些问题" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>起初尝试用context通知consume退出</p>
<ul>
<li>consume的select中可以增加ctx.Done，用来做退出通知
<ul>
<li>select的多个case同时触发时，会随机选择一个</li>
<li>在退出后还要再消费完chan，代码偏复杂</li>
</ul>
</li>
<li>close(chan) 或者 写入nil 标识关闭，这样退出for循环后一定已经消费完chan</li>
</ul>
<p>标准库log实现</p>
<ul>
<li>go1.18</li>
</ul>
<pre tabindex="0"><code>
// Output writes the output for a logging event. The string s contains
// the text to print after the prefix specified by the flags of the
// Logger. A newline is appended if the last character of s is not
// already a newline. Calldepth is used to recover the PC and is
// provided for generality, although at the moment on all pre-defined
// paths it will be 2.
func (l *Logger) Output(calldepth int, s string) error {
	now := time.Now() // get this early.
	var file string
	var line int
	l.mu.Lock()
	defer l.mu.Unlock()
	if l.flag&amp;(Lshortfile|Llongfile) != 0 {
		// Release lock while getting caller info - it&#39;s expensive.
		l.mu.Unlock()
		var ok bool
		_, file, line, ok = runtime.Caller(calldepth)
		if !ok {
			file = &#34;???&#34;
			line = 0
		}
		l.mu.Lock()
	}
	l.buf = l.buf[:0]
	l.formatHeader(&amp;l.buf, now, file, line)
	l.buf = append(l.buf, s...)
	if len(s) == 0 || s[len(s)-1] != &#39;\n&#39; {
		l.buf = append(l.buf, &#39;\n&#39;)
	}
	_, err := l.out.Write(l.buf)
	return err
}
</code></pre><p>mutex临界区较大</p>
<p>注释写到 Release lock while getting caller info - it&rsquo;s expensive.</p>
<p>测试了下runtime.Caller的耗时</p>
<pre tabindex="0"><code>func main() {
	for i := 0; i &lt; 10; i++ {
		start := time.Now()
		runtime.Caller(2)
		fmt.Println(&#34;cost&#34;, time.Since(start))
	}
}
</code></pre><p>Caller第一次调用耗时15us，后续在500ns-1us左右。 开销确实大。</p>
<p>同样功能C++可以用宏定义在编译期得到结果</p>
<ul>
<li>go1.21</li>
</ul>
<p>mutex加锁范围变化，临界区变小</p>
<p>增加了[]byte池，不再是每个Logger对象使用一个buf []byte</p>
<pre tabindex="0"><code>func (l *Logger) output(pc uintptr, calldepth int, appendOutput func([]byte) []byte) error {
	now := time.Now() // get this early.

	// Load prefix and flag once so that their value is consistent within
	// this call regardless of any concurrent changes to their value.
	prefix := l.Prefix()
	flag := l.Flags()

	var file string
	var line int
	if flag&amp;(Lshortfile|Llongfile) != 0 {
		if pc == 0 {
			var ok bool
			_, file, line, ok = runtime.Caller(calldepth)
			if !ok {
				file = &#34;???&#34;
				line = 0
			}
		}
	}

	buf := getBuffer()
	defer putBuffer(buf)
	formatHeader(buf, now, prefix, flag, file, line)
	*buf = appendOutput(*buf)
	if len(*buf) == 0 || (*buf)[len(*buf)-1] != &#39;\n&#39; {
		*buf = append(*buf, &#39;\n&#39;)
	}

	l.outMu.Lock()
	defer l.outMu.Unlock()
	_, err := l.out.Write(*buf)
	return err
}

var bufferPool = sync.Pool{New: func() any { return new([]byte) }}

func getBuffer() *[]byte {
	p := bufferPool.Get().(*[]byte)
	*p = (*p)[:0]
	return p
}
</code></pre><h1 id="四总结">四、总结<a href="#四总结" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>使用异步io.WriteCloser，避免打印日志时发生阻塞，避免了接口请求失败</p>
<ul>
<li>遗留问题：sync.Mutex</li>
</ul>
<p>发生问题时日志可以看出，mutex的等待队列不是先进先出，有着一些随机性</p>
<p>sync.Mutex有饥饿模式 ，饥饿模式下也不是先进先出吗？</p>
<p>怎样复现日志乱序的现象？</p>
<p>后续有时间再写篇博客分析</p>

      </div></div>

  
    
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="/posts/golang-mutex/">
                <span class="button__icon">←</span>
                <span class="button__text">Golang Mutex</span>
            </a>
        </span>
        
        
        <span class="button next">
            <a href="/posts/high-concurrency-system-design/">
                <span class="button__text"></span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2024 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
