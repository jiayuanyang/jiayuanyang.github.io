<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Golang Mutex :: jiayuan&#39;s Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Golang sync.Mutex 源码分析， 普通模式 饥饿模式" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="/posts/golang-mutex/" />






  
  
  
  
  
  <link rel="stylesheet" href="/styles.css">







  <link rel="shortcut icon" href="/img/theme-colors/orange.png">
  <link rel="apple-touch-icon" href="/img/theme-colors/orange.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Golang Mutex">
<meta property="og:description" content="Golang sync.Mutex 源码分析， 普通模式 饥饿模式" />
<meta property="og:url" content="/posts/golang-mutex/" />
<meta property="og:site_name" content="jiayuan&#39;s Blog" />

  
    <meta property="og:image" content="/img/favicon/orange.png">
  

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2024-05-20 23:32:13 &#43;0800 &#43;0800" />












</head>
<body class="orange">


<div class="container full">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    jiayuan&#39;s Blog
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/tags">Tags</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about" >About</a></li>
        
      
        
          <li><a href="/tags" >Tags</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="/posts/golang-mutex/">Golang Mutex</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-05-20</time></div>

  
    <span class="post-tags">
      
      #<a href="/tags/go/">Go</a>&nbsp;
      
      #<a href="/tags/mutex/">mutex</a>&nbsp;
      
      #<a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>&nbsp;
      
      #<a href="/tags/futex/">futex</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h1 id="问题引入">问题引入<a href="#问题引入" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>上一篇博客提到IO阻塞，打印log时，时间可能是乱序的</p>
<p>由此来分析Go中sync.Mutex在不同场景的表现</p>
<p>测试代码 go1.19，在每分钟0s Write时阻塞3s</p>
<pre tabindex="0"><code>package main

import (
	&#34;log&#34;
	&#34;math/rand&#34;
	&#34;os&#34;
	&#34;sync/atomic&#34;
	&#34;time&#34;
)

type DelayWriter struct {
	*os.File
}

var timeslot [60]int64

func (w *DelayWriter) Write(b []byte) (int, error) {
	now := time.Now()
	if now.Second() == 0 &amp;&amp; atomic.AddInt64(&amp;timeslot[now.Minute()], 1) == 1 {
		time.Sleep(time.Millisecond * 3333) // 每分钟 0s，模拟写日志阻塞
	}
	return w.File.Write(b)
}

func NewDelayWriter(filename string) *DelayWriter {
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR|os.O_APPEND|os.O_TRUNC, 0666)
	if err != nil {
		panic(err)
	}
	return &amp;DelayWriter{f}
}

var logger = log.New(NewDelayWriter(&#34;test.log&#34;), &#34;&#34;, log.LstdFlags|log.Lmicroseconds|log.Lshortfile)

func main() {
	for i := 0; i &lt; 100; i++ {
		go func(index int) {
			var seq int
			for {
				seq++

				r := rand.Int31n(1000) + 100
				time.Sleep(time.Duration(r) * time.Millisecond)

				go serve(index, seq) // 处理请求
			}
		}(i)
	}

	time.Sleep(time.Minute * 2)
	logger.Println(&#34;end&#34;)
}

func serve(index int, seq int) {
	logger.Println(&#34;recv request&#34;, index, seq)
}
</code></pre><p>运行结果，可以看到在0s附近，时间有递增、递减、反复变化</p>
<p><img src="/img/golang-mutex-log.jpg" alt="log"></p>
<h1 id="syncmutex实现分析">sync.Mutex实现分析<a href="#syncmutex实现分析" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>当前sync.Mutex的实现比较复杂，引入了普通（normal）模式，饥饿（starvation）模式</p>
<p>sync.Mutex代码经过了4个版本变化，直接看最新代码较难理解，接下来按照4个版本变化依次介绍</p>
<h2 id="信号量原语">信号量原语<a href="#信号量原语" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<pre tabindex="0"><code>// Semacquire waits until *s &gt; 0 and then atomically decrements it.
// It is intended as a simple sleep primitive for use by the synchronization
// library and should not be used directly.
func runtime_Semacquire(s *uint32)

// Semrelease atomically increments *s and notifies a waiting goroutine
// if one is blocked in Semacquire.
// It is intended as a simple wakeup primitive for use by the synchronization
// library and should not be used directly.
func runtime_Semrelease(s *uint32)
</code></pre><h2 id="v1simple-implementation">V1：Simple implementation.<a href="#v1simple-implementation" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<pre tabindex="0"><code>type Mutex struct {
    key  int32 // Indication of whether the lock is held
    sema int32 // Semaphore dedicated to block/wake up goroutine
}

func (m *Mutex) Lock() {
    if atomic.AddInt32(&amp;m.key, 1) == 1 {
        return
    }
    semacquire(&amp;m.sema)
}

func (m *Mutex) Unlock() {
    if atomic.AddInt32(&amp;m.key, -1) == 0 {
        return
    }
    semrelease(&amp;m.sema)
}
</code></pre><h3 id="lock">Lock<a href="#lock" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>key原子增加
<ul>
<li>新值为1获取到锁；否则：</li>
<li>信号量semacquire</li>
</ul>
</li>
</ul>
<h3 id="unlock">Unlock<a href="#unlock" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>key原子增加-1
<ul>
<li>新值为0，说明没有其他在等待的，直接返回；否则：</li>
<li>信号量semrelease，唤醒等待的goroutine</li>
</ul>
</li>
</ul>
<h3 id="举例">举例<a href="#举例" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ol>
<li>goroutine1（简称g1） Lock</li>
<li>g2请求Lock，semacquire</li>
<li>g1 Unlock，semrelease，唤醒等待者g2</li>
<li>g2进入临界区操作，操作完 再Unlock</li>
</ol>
<p>如果g2 原子incr key，还未调用 semacquire(&amp;m.sema)</p>
<p>g1先semrelease(&amp;m.sema)，还能不能唤醒g2？</p>
<ol>
<li>g1 Lock 成功</li>
<li>g2 Lock，进程暂停</li>
<li>g1 Unlock，semrelease(&amp;m.sema)，此时g1还未休眠，无法唤醒，信号量自增</li>
<li>g2 进程继续，semacquire(&amp;m.sema)</li>
</ol>
<p>g2执行semacquire(&amp;m.sema)  后</p>
<blockquote>
<p>Semacquire waits until *s &gt; 0 and then atomically decrements it.</p>
</blockquote>
<p>还是能够正常执行</p>
<h2 id="v2new-goroutine-participates-in-lock-competition">V2：New Goroutine participates in lock competition.<a href="#v2new-goroutine-participates-in-lock-competition" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>信号量先进先出，V1版本如果有goroutine在等待了，新来的<strong>正在</strong>运行的goroutine也必须等待</p>
<p>唤醒老的在睡眠的goroutine，显然开销大于正在运行的goroutine直接获取锁</p>
<p>V2版本，允许已经有goroutine睡眠等待时，正在运行的goroutine先获取到锁</p>
<pre tabindex="0"><code>type Mutex struct {
   state int32
   sema  uint32
}

const (
   mutexLocked = 1 &lt;&lt; iota // mutex is locked
   mutexWoken
   mutexWaiterShift = iota
)
</code></pre><h3 id="lock-1">Lock<a href="#lock-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre tabindex="0"><code>func (m *Mutex) Lock() {
   if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
      return
   }

   awoke := false
   for {
      old := m.state
      var new int32
      if old&amp;mutexLocked == 0 {
         new = old | mutexLocked
      } else {
      	 new = old + 1&lt;&lt;mutexWaiterShift
      }
      if awoke {
         new &amp;^= mutexWoken
      }
      if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
         if old&amp;mutexLocked == 0 {
            break
         }
         runtime.Semacquire(&amp;m.sema)
         awoke = true
      }
   }
}
</code></pre><ul>
<li>state cas从0到1成功，直接得到锁； 否则
<ul>
<li>for 循环，进行cas操作
<ul>
<li>如果当前没有锁标记，加上锁标记</li>
<li>有锁标记，增加一个等待计数</li>
<li>另外，awoke为true时，清除mutexWoken比特位</li>
</ul>
</li>
<li>cas进行更新，更新成功时
<ul>
<li>旧值没有锁标记，表示本次cas拿到锁，直接退出；否则</li>
<li>Semacquire，进入睡眠等待，等待结束后，awoke置为true</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="unlock-1">Unlock<a href="#unlock-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre tabindex="0"><code>func (m *Mutex) Unlock() {
   new := atomic.AddInt32(&amp;m.state, -mutexLocked)

   old := new
   for {
      if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken) != 0 {
         return
      }

      new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
      if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
         runtime.Semrelease(&amp;m.sema)
         return
      }
      old = m.state
   }
}
</code></pre><ul>
<li>原子减-1</li>
<li>for循环
<ul>
<li>如果没有等待者， 或者 有lock/woken标记， 退出；否则</li>
<li>cas更新，新值为减去1个等待计数|woken标记
<ul>
<li>cas成功，Semrelease唤醒一个等待者</li>
<li>cas失败， 继续判断</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="举例-1">举例<a href="#举例-1" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ol>
<li>
<p>g1 Lock</p>
</li>
<li>
<p>g2, g3 请求Lock，进入休眠等待</p>
</li>
<li>
<p>g1 Unlock 和 g4 Lock， g5 Lock几乎同时发生</p>
<ol>
<li>
<p>第一种情况 g1 Unlock 先完成了原子-1</p>
<ol>
<li>g4, g5看到 old&amp;mutexLocked == 0，都增加locked比特，进行cas更新</li>
<li>g4 g5其中一个更新成功， 获取到锁</li>
<li>另一个更新失败，再次进入for循环，
<ol>
<li>看到  old&amp;mutexLocked != 0， 增加等待计数，cas更新成功后休眠等待</li>
</ol>
</li>
<li>此时g1 进入for循环， 看到已经<strong>有了mutex标记</strong>，结束Unlock，<strong>不需要再进行唤醒</strong></li>
</ol>
</li>
<li>
<p>第二种情况 g1 Unlock 先完成了原子-1，并且cas新增woken标记成功</p>
<ol>
<li>g4其中一个获取锁成功，g5获取锁失败，再次进入for循环，<strong>还未进行第二次cas更新</strong></li>
<li>g4 很快完成操作，调用Unlock</li>
<li>此时，g4看到有<strong>woken标记</strong>，结束Unlock，不需要再进行唤醒
<ol>
<li>如果g4第二次cas更新成功，去掉woken标记，此时g4还会进行唤醒</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="问题">问题<a href="#问题" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<ul>
<li>为什么要加woken标记</li>
<li>CAS会不会有ABA问题？</li>
</ul>
<h4 id="问题1为什么要加woken标记">问题1：为什么要加woken标记<a href="#问题1为什么要加woken标记" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>防止惊群，只需要唤醒一个</p>
<p>g1 Lock成功</p>
<p>g2, g3, g4 请求Lock， 进入睡眠等待</p>
<p>g1 Unlock，准备semrelease（还未调用）</p>
<p>此时 新来g5 可以Lock成功</p>
<p>g5 Unlock，准备semrelease（还未调用）</p>
<p>然后 g1, g5 同时semrelease，会唤醒多个在睡眠等待的goroutine</p>
<hr>
<p>加了woken标记，就只会唤醒一个</p>
<p>woken的goroutine和新来的（也可能没有新来的）竞争， 失败则再次睡眠</p>
<p>被woken的会去掉woken标记进行cas， cas更新成功，都会去掉woken标记，未抢到锁时还会进入睡眠</p>
<hr>
<h4 id="问题2会不会有aba问题">问题2：会不会有ABA问题<a href="#问题2会不会有aba问题" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>不会</p>
<ul>
<li>Unlock时， cas什么时候失败？</li>
</ul>
<ol>
<li>Unlock 原子-1后，没有lock标记，新来的g先于Unlock的cas加上了lock，cas失败
<ol>
<li>此时，在进入判断，会认为有lock标记，退出</li>
</ol>
</li>
<li>和上面类似，Unlock 原子-1后，没有lock标记，新来的g先于Unlock的cas加上了lock，cas失败。但是在Unlock再次判断之前，新来的g调用了Unlock。
<ol>
<li>此时有两个g在Unlock</li>
<li>两个都判断没有lock标记，假设还有一个等待者， 这是二者都会尝试加上woken标记，并减去1个等待者</li>
<li>只有一个添加woken成功，然后唤醒等待者，另一个cas失败，再次判断，由于woken存在或者等待者为0退出</li>
</ol>
</li>
</ol>
<ul>
<li>cas判断，会不会有N次semacquire，但是semrelease小于N?
<ul>
<li>不会，有多少次 semacquire， 就有多少次 semrelease</li>
</ul>
</li>
</ul>
<h2 id="v3give-new-goroutines-some-more-chances">V3：Give new goroutines some more chances.<a href="#v3give-new-goroutines-some-more-chances" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>增加自旋</p>
<p>有mutexLocked时，进行有限次数自旋，并尝试cas增加mutexWoken标记</p>
<p>整体逻辑和V2类似</p>
<h3 id="lock-2">Lock<a href="#lock-2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre tabindex="0"><code>func (m *Mutex) Lock() {
    // Fast path: grab unlocked mutex.
    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
        return
    }

    awoke := false
    iter := 0
    for {
        old := m.state
        new := old | mutexLocked
        if old&amp;mutexLocked != 0 {
            if runtime_canSpin(iter) {
                if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
                    awoke = true
                }
                runtime_doSpin()
                iter++
                continue
            }
            new = old + 1&lt;&lt;mutexWaiterShift
        }
        if awoke {
            new &amp;^= mutexWoken
        }
        if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
            if old&amp;mutexLocked == 0 {
                break
            }
            runtime_Semacquire(&amp;m.sema)
            awoke = true
            iter = 0
        }
    }
}
</code></pre><h3 id="unlock-2">Unlock<a href="#unlock-2" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>逻辑同V2</p>
<h2 id="v4solve-the-old-goroutine-starvation-problem">V4：Solve the old goroutine starvation problem.<a href="#v4solve-the-old-goroutine-starvation-problem" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>V3版本新来的goroutine更容易竞争到锁，老的竞争者可能一直得不到锁</p>
<p>V4版本解决饥饿问题</p>
<pre tabindex="0"><code>const (
    mutexLocked = 1 &lt;&lt; iota // mutex is locked
    mutexWoken
    mutexStarving // separate out a starvation token from the state field
    mutexWaiterShift = iota
    starvationThresholdNs = 1e6    
)
</code></pre><h3 id="lock-3">Lock<a href="#lock-3" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre tabindex="0"><code>func (m *Mutex) Lock() {
	// Fast path: grab unlocked mutex.
	if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
		return
	}
	// Slow path (outlined so that the fast path can be inlined)
	m.lockSlow()
}

func (m *Mutex) lockSlow() {
	var waitStartTime int64
	starving := false
	awoke := false
	iter := 0
	old := m.state
	for {
		// Don&#39;t spin in starvation mode, ownership is handed off to waiters
		// so we won&#39;t be able to acquire the mutex anyway.
		if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {
			// Active spinning makes sense.
			// Try to set mutexWoken flag to inform Unlock
			// to not wake other blocked goroutines.
			if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
				awoke = true
			}
			runtime_doSpin()
			iter++
			old = m.state
			continue
		}
		new := old
		// Don&#39;t try to acquire starving mutex, new arriving goroutines must queue.
		if old&amp;mutexStarving == 0 {
			new |= mutexLocked
		}
		if old&amp;(mutexLocked|mutexStarving) != 0 {
			new += 1 &lt;&lt; mutexWaiterShift
		}
		// The current goroutine switches mutex to starvation mode.
		// But if the mutex is currently unlocked, don&#39;t do the switch.
		// Unlock expects that starving mutex has waiters, which will not
		// be true in this case.
		if starving &amp;&amp; old&amp;mutexLocked != 0 {
			new |= mutexStarving
		}
		if awoke {
			// The goroutine has been woken from sleep,
			// so we need to reset the flag in either case.
			if new&amp;mutexWoken == 0 {
				throw(&#34;sync: inconsistent mutex state&#34;)
			}
			new &amp;^= mutexWoken
		}
		if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
			if old&amp;(mutexLocked|mutexStarving) == 0 {
				break // locked the mutex with CAS
			}
			// If we were already waiting before, queue at the front of the queue.
			queueLifo := waitStartTime != 0
			if waitStartTime == 0 {
				waitStartTime = runtime_nanotime()
			}
			runtime_SemacquireMutex(&amp;m.sema, queueLifo, 1)
			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
			old = m.state
			if old&amp;mutexStarving != 0 {
				// If this goroutine was woken and mutex is in starvation mode,
				// ownership was handed off to us but mutex is in somewhat
				// inconsistent state: mutexLocked is not set and we are still
				// accounted as waiter. Fix that.
				if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {
					throw(&#34;sync: inconsistent mutex state&#34;)
				}
				delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)
				if !starving || old&gt;&gt;mutexWaiterShift == 1 {
					// Exit starvation mode.
					// Critical to do it here and consider wait time.
					// Starvation mode is so inefficient, that two goroutines
					// can go lock-step infinitely once they switch mutex
					// to starvation mode.
					delta -= mutexStarving
				}
				atomic.AddInt32(&amp;m.state, delta)
				break
			}
			awoke = true
			iter = 0
		} else {
			old = m.state
		}
	}

}
</code></pre><h3 id="unlock-3">Unlock<a href="#unlock-3" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<pre tabindex="0"><code>func (m *Mutex) Unlock() {
	// Fast path: drop lock bit.
	new := atomic.AddInt32(&amp;m.state, -mutexLocked)
	if new != 0 {
		// Outlined slow path to allow inlining the fast path.
		// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.
		m.unlockSlow(new)
	}
}

func (m *Mutex) unlockSlow(new int32) {
	if new&amp;mutexStarving == 0 {
		old := new
		for {
			// If there are no waiters or a goroutine has already
			// been woken or grabbed the lock, no need to wake anyone.
			// In starvation mode ownership is directly handed off from unlocking
			// goroutine to the next waiter. We are not part of this chain,
			// since we did not observe mutexStarving when we unlocked the mutex above.
			// So get off the way.
			if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
				return
			}
			// Grab the right to wake someone.
			new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
			if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
				runtime_Semrelease(&amp;m.sema, false, 1)
				return
			}
			old = m.state
		}
	} else {
		// Starving mode: handoff mutex ownership to the next waiter.
		// Note: mutexLocked is not set, the waiter will set it after wakeup.
		// But mutex is still considered locked if mutexStarving is set,
		// so new coming goroutines won&#39;t acquire it.
		runtime_Semrelease(&amp;m.sema, true, 1)
	}
}
</code></pre><h2 id="总结">总结<a href="#总结" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<ul>
<li>V1版本：先进先出，新来的goroutine只能排队</li>
<li>V2版本：新来的g和被唤醒的g竞争，可能直接拿到锁
<ul>
<li>g被唤醒不是直接拿到锁， 与新来的g竞争</li>
<li>最多只有一个g被唤醒，被唤醒的g竞争失败，清空woken标记，再次睡眠</li>
</ul>
</li>
<li>V3版本：增加自旋逻辑，临界区较少时，自旋一会就能拿到锁，无需进入睡眠
<ul>
<li>自旋时会尝试设置woken标记， 通知Unlock无需唤醒其他等待者</li>
</ul>
</li>
<li>V4版本：解决饥饿，新增mutexStarving标记位，引入普通/饥饿模式
<ul>
<li>普通模式，同上述</li>
<li>饥饿模式：
<ul>
<li>新来的g，不竞争锁， 在队尾等待</li>
<li>被唤醒的g，无需再次竞争，直接得到锁</li>
<li>Unlock，不设置woken标记， 直接唤醒</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="回到最开始的问题">回到最开始的问题<a href="#回到最开始的问题" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<ul>
<li>为什么日志时间乱序？ mutex是先进先出的吗</li>
</ul>
<p>线上go版本是1.16，是上面V4版本的实现，以测试代码为例</p>
<p>在每分钟0s Write时阻塞，此时后续的g，会先进行自旋，然后得不到锁，进入睡眠</p>
<p>到这里还都是按照先后顺序的，先进入，先打印，不应该出现时间乱序</p>
<p>第一个g，阻塞3s后，Write，然后Unlock</p>
<p>如果此时没有新来的g，交给sema第一个等待者，wake后没有竞争直接拿到锁，是不会进入饥饿模式的</p>
<p>但是如果有新来的g，Unlock时处于普通模式，新来的g与被唤醒的g竞争</p>
<p>1）如果新来的g（g1）竞争到，被唤醒的g0等待了3s，会cas进入饥饿模式。不过，这个cas不一定成功。g1 Unlock时刚好新来g2，仍然可以得到锁。g0会再次cas更新，直到CAS成功，一定能够加上mutexStarving标记</p>
<p>如果在CAS中直接获取到锁，会加上starving标记</p>
<p>如果在CAS中没有获取到锁，也会加上starving标记，并且加入到sema的队头，仍然符合先进先出的顺序</p>
<p>2）如果被唤醒的g竞争到，不会进入饥饿模式，新来的g加到信号量队尾</p>
<hr>
<ul>
<li>
<p>上述分析说明mutex整体上是先进先出的</p>
</li>
<li>
<p>普通模式，新来的g与被唤醒的g竞争，新来的g优势大</p>
</li>
<li>
<p>即使实际已经饥饿，等待时间过长，但是依次唤醒，依次都得到所有权，并不会转变到饥饿模式</p>
<ul>
<li>但是一但没有获取到锁，就会加上starving标记，后续进入饥饿模式</li>
</ul>
</li>
<li>
<p>饥饿模式时，新来的g直接加入队尾</p>
</li>
</ul>
<hr>
<p>那么， 上述日志的时间乱序，另有原因</p>
<p>标准库log方法</p>
<pre tabindex="0"><code>func (l *Logger) Output(calldepth int, s string) error {
	now := time.Now() // get this early.
	var file string
	var line int
	l.mu.Lock()
	defer l.mu.Unlock()
	if l.flag&amp;(Lshortfile|Llongfile) != 0 {
		// Release lock while getting caller info - it&#39;s expensive.
		l.mu.Unlock()
		var ok bool
		_, file, line, ok = runtime.Caller(calldepth)
		if !ok {
			file = &#34;???&#34;
			line = 0
		}
		l.mu.Lock()
	}
	l.buf = l.buf[:0]
	l.formatHeader(&amp;l.buf, now, file, line)
	l.buf = append(l.buf, s...)
	if len(s) == 0 || s[len(s)-1] != &#39;\n&#39; {
		l.buf = append(l.buf, &#39;\n&#39;)
	}
	_, err := l.out.Write(l.buf)
	return err
}
</code></pre><h2 id="解释现象-个人理解">解释现象 个人理解<a href="#解释现象-个人理解" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>时间是在Lock之前获取，为了获取代码行信息，会先Unlock，得到代码行数后，再Lock</p>
<p>日志中时间乱序是因为 Unlock后，runtime.Caller耗时有差异，再次Lock的顺序与获取time.Now顺序不一致</p>
<ul>
<li>图片里第一个03s是因为新来的g先获取到了锁</li>
<li>后续进入饥饿模式，时间是按顺序的</li>
<li>饥饿模式退出后，有新来的g获取到了锁</li>
</ul>
<hr>
<ul>
<li>去掉 Lshortfile|Llongfile， 再次运行，只会有零星的几个时间乱序，符合上述描述，还未实际进入饥饿模式时，新来的g也能够获取到锁</li>
<li>将标准库内 runtime.Caller 注释掉，Lock， 仍然是Unlock， Lock, Unlock的顺序， 有阻塞3s，日志时间是有序的</li>
</ul>
<h2 id="标准库log的优化">标准库log的优化<a href="#标准库log的优化" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>go1.21 <a href="https://github.com/golang/go/commit/c3b4c27fd31b51226274a0c038e9c10a65f11657">代码</a> 修改了log实现</p>
<pre tabindex="0"><code>Performance:
	name           old time/op  new time/op  delta
	Concurrent-24  19.9µs ± 2%   8.3µs ± 1%  -58.37%  (p=0.000 n=10+10)
</code></pre><p>不再是每个Log对象用一个buf，使用了[]byte池</p>
<p>mutex只锁Write方法，runtime.Caller提前计算</p>
<p>用新版本测试，不会再出现时间乱序的问题</p>
<h2 id="futex">futex<a href="#futex" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>linux用futex实现pthread_mutex_t</p>
<p><a href="https://man7.org/linux/man-pages/man2/futex.2.html">futex(2) — Linux manual page</a></p>
<p>与go的实现有何不同</p>
<p>后续分析</p>
<h1 id="参考文章">参考文章<a href="#参考文章" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p><a href="https://levelup.gitconnected.com/deep-understanding-of-golang-mutex-9964b02c56e9">Deep Understanding of Golang Mutex</a></p>

      </div></div>

  
    
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="/posts/innodb-space/">
                <span class="button__icon">←</span>
                <span class="button__text">InnoDB索引占用空间分析</span>
            </a>
        </span>
        
        
        <span class="button next">
            <a href="/posts/golang-async-log/">
                <span class="button__text">Go异步日志实现</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2024 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
